#  BSD LICENSE
#
#  Copyright (c) 2021 Samsung Electronics Co., Ltd.
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in
#      the documentation and/or other materials provided with the
#      distribution.
#    * Neither the name of Samsung Electronics Co., Ltd. nor the names of
#      its contributors may be used to endorse or promote products derived
#      from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---

- name: Set target/host group vars
  set_fact:
    target_hostnames: "{{ (groups['servers'] | d([]) + groups['targets'] | d([])) | unique }}"
    host_hostnames: "{{ (groups['servers'] | d([]) + groups['hosts'] | d([])) | unique }}"

- name: Stat DSS Minio path
  stat:
    path: "{{ minio_dir }}"
  register: dss_minio_path
  when: inventory_hostname in host_hostnames

- name: Assert DSS Minio path exists
  assert:
    that: dss_minio_path.stat.exists
    fail_msg: DSS Minio is not installed. Execute 'deploy_dss_software.yml' playbook first.
  when: inventory_hostname in host_hostnames

- name: Get TCP IP lists and NUMA
  include_role:
    name: get_tcp_numa
  when: >
    inventory_hostname in host_hostnames or
    inventory_hostname in groups['clients']

- name: Get clusters
  include_role:
    name: get_clusters
  when: >-
    inventory_hostname in host_hostnames or
    inventory_hostname in target_hostnames

- name: Set minio_endpoints var
  set_fact:
    minio_endpoints: >-
      [
        {% for cluster in clusters %}
          {% set cluster_loop = loop %}
          {% for endpoint in cluster.endpoints %}
            {% set endpoint_loop = loop %}
            {% set index_scale = { 'value': 0 } %}
            {% if s3_benchmark_max_instances_per_client > 0 %}
              {% if index_scale.update({ 'value': (endpoint.vlan_index / s3_benchmark_max_instances_per_client) | round(0,'floor') | int }) %}{% endif %}
            {% endif %}
            {
              'endpoint': '{{ endpoint.ipv4 }}',
              'id': '{{ cluster.id }}',
              'vlan_index': {{ endpoint.vlan_index }},
              'host_index': {{ endpoint.host_index }},
              'random_host_index': {{ endpoint.random_host_index + (index_scale.value * (groups['servers'] | length)) }}
            }{% if not cluster_loop.last or not endpoint_loop.last %},{% endif %}
          {% endfor %}
        {% endfor %}
      ]
  run_once: true

- name: Assign endpoints
  set_fact:
    assigned_endpoints: >-
      [
        {% for vlan_id in range(tcp_ip_list | length) %}
          {% if minio_endpoints | selectattr('random_host_index', 'equalto', ansible_loop.index0) | selectattr('vlan_index', 'equalto', vlan_id) | list | length > 0 %}
            {{ minio_endpoints | selectattr('random_host_index', 'equalto', ansible_loop.index0) | selectattr('vlan_index', 'equalto', vlan_id) | first }}
            {% if not loop.last and minio_endpoints | selectattr('random_host_index', 'equalto', ansible_loop.index0) | selectattr('vlan_index', 'equalto', vlan_id + 1) | list | length > 0 %},{% endif %}
          {% endif %}
        {% endfor %}
      ]
  loop: "{{ groups['clients'] }}"
  loop_control:
    extended: true
    loop_var: client
  when: inventory_hostname == client

- name: Set num_s3_endpoints var
  set_fact:
    num_s3_endpoints: "{{ num_s3_endpoints | d(0) | int + (hostvars[client].assigned_endpoints | length) }}"
  loop: "{{ groups['clients'] }}"
  loop_control:
    loop_var: client
  run_once: true

- name: s3-benchmark PUT
  include_tasks: s3_benchmark.yml
  vars:
    operation: PUT
  when: inventory_hostname in groups['clients']

- name: Start Compaction
  include_role:
    name: start_compaction
  when:
    - inventory_hostname in target_hostnames
    - dss_target_mode is search('kv_block')

- name: Set s3_put_speed var
  set_fact:
    s3_put_speed: "{{ s3_speed }}"
  run_once: true

- name: s3-benchmark GET
  include_tasks: s3_benchmark.yml
  vars:
    operation: GET
  when: inventory_hostname in groups['clients']

- name: Set s3_get_speed var
  set_fact:
    s3_get_speed: "{{ s3_speed }}"
  run_once: true

- name: s3-benchmark DEL
  include_tasks: s3_benchmark.yml
  vars:
    operation: DEL
  when: inventory_hostname in groups['clients']

- name: Start Compaction
  include_role:
    name: start_compaction
  when:
    - inventory_hostname in target_hostnames
    - dss_target_mode is search('kv_block')

- name: Print combined s3_benchmark PUT and GET throughput
  debug:
    msg: |
      Num. MinIO Hosts: {{ host_hostnames | length }}
      Num. MinIO Endpoints: {{ minio_endpoints | length }}
      Num. Clients: {{ groups['clients'] | length }}
      Max. s3-benchmark instances per client: {{ s3_benchmark_max_instances_per_client }}
      Total s3-benchmark instances: {{ num_s3_endpoints }}
      ------------------------------------------------------------
      PUT: {{ s3_put_speed }}
      GET: {{ s3_get_speed }}
  run_once: true
